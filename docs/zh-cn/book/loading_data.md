# 加载数据

之前我们使用了 `ls`, `ps`, `date`, `sys` 来从文件系统、进程、日期时间和系统本身加载了数据。每条命令都以表的形式提供了我们能够探索到的信息。
我们在工作时也可通过其他方法将数据加载为表。

## 打开文件

处理数据时 Nu 最有力的工具就是 `open` 命令。它时一个多用工具，可以在许多不同数据格式下工作。
要明白这一点，让我们尝试来打开一个 json 文件：

```
> open editors/vscode/package.json
──────────────────┬───────────────────────────────────────────────────────────────────────────────
 name             │ lark
 description      │ Lark support for VS Code
 author           │ Lark developers
 license          │ MIT
 version          │ 1.0.0
 repository       │ [row type url]
 publisher        │ vscode
 categories       │ [table 0 rows]
 keywords         │ [table 1 rows]
 engines          │ [row vscode]
 activationEvents │ [table 1 rows]
 main             │ ./out/extension
 contributes      │ [row configuration grammars languages]
 scripts          │ [row compile postinstall test vscode:prepublish watch]
 devDependencies  │ [row @types/mocha @types/node tslint typescript vscode vscode-languageclient]
──────────────────┴───────────────────────────────────────────────────────────────────────────────
```

就像 `ls` 一样，打开一个 Nu 能够理解的文件类型将给我们比文本（或字节流）更丰富的信息。
这里我们打开了一个 JavaScript 项目的 "package.json" 文件。Nu 可以识别 JSON 文本并以表的形式返回数据。

如果我们想要检查这个项目的版本，可以用 `get` 指令：

```
> open editors/vscode/package.json | get version
1.0.0
```

Nu 目前支持直接从以下格式加载表数据：

* json
* yaml
* toml
* xml
* csv
* ini

但是，当你加载另外的文本文件时会发生什么呢？让我们试一试：

```
> open README.md
```

我们展示了文件的内容。如果文件过大，我们可以得到一个受控的滚动视图来查看文件并返回终端。有助于可读性，Nu 还会高亮一般文件格式，例如源代码文件、Markdown 等。

在表象之下，Nu 在这些文本文件中看到的是一个大字符串。 接下来，我们将讨论如何使用这些字符串以从中获取所需的数据。

## 处理字符串

处理来自 Nu 外部的数据的一个要点是，它并不总是采用 Nu 可以理解的格式。 通常，此数据以字符串形式提供给我们。

让我们想象我们得到了这样一个数据文件：

```
> open people.txt
Octavia | Butler | Writer
Bob | Ross | Painter
Antonio | Vivaldi | Composer
```

我们想要的每个数据都用管道符（'|'）分隔，并且每个人在独立的行中。Nu 默认没有管道符分隔的文件格式，所以我们不得不自行解析它。

首先，我们想要做的是每次处理一行：

```
> open people.txt | lines
───┬──────────────────────────────
 0 │ Octavia | Butler | Writer
 1 │ Bob | Ross | Painter
 2 │ Antonio | Vivaldi | Composer
───┴──────────────────────────────
```

我们可以看到我们正在处理这些行，因为我们回到了表格中。 下一步是查看是否可以将行拆分成更有用的内容。 为此，我们将使用 `split-column` 命令。 顾名思义，「分隔列」为我们提供了一种将定界字符串拆分为列的方法。 我们告诉它分隔符是什么，其余的将由它完成：

```
> open people.txt | lines | split-column "|"
───┬──────────┬───────────┬───────────
 # │ Column1  │ Column2   │ Column3
───┼──────────┼───────────┼───────────
 0 │ Octavia  │  Butler   │  Writer
 1 │ Bob      │  Ross     │  Painter
 2 │ Antonio  │  Vivaldi  │  Composer
───┴──────────┴───────────┴───────────
```

这看起来就差不多了。但貌似它还有一些额外的空白字符。让我们 `trim` 掉这些空格：

```
> open people.txt | lines | split-column "|" | str trim
───┬─────────┬─────────┬──────────
 # │ Column1 │ Column2 │ Column3
───┼─────────┼─────────┼──────────
 0 │ Octavia │ Butler  │ Writer
 1 │ Bob     │ Ross    │ Painter
 2 │ Antonio │ Vivaldi │ Composer
───┴─────────┴─────────┴──────────
```

不错。 `split-column` 命令得到了我们可以使用的数据。它也给了我们一行默认列名：

```
> open people.txt | lines | split-column "|" | str trim | get Column1
───┬─────────
 0 │ Octavia
 1 │ Bob
 2 │ Antonio
───┴─────────
```

我们也可以用我们提供的列名代替默认的：

```
> open people.txt | lines | split-column "|" first_name last_name job | str trim
───┬────────────┬───────────┬──────────
 # │ first_name │ last_name │ job
───┼────────────┼───────────┼──────────
 0 │ Octavia    │ Butler    │ Writer
 1 │ Bob        │ Ross      │ Painter
 2 │ Antonio    │ Vivaldi   │ Composer
───┴────────────┴───────────┴──────────
```

现在，我们的数据在一个表中了，我们可以使用之前我们对表所用的一切命令来处理它：

```
> open people.txt | lines | split-column "|" first_name last_name job | str trim | sort-by first_name
───┬────────────┬───────────┬──────────
 # │ first_name │ last_name │ job
───┼────────────┼───────────┼──────────
 0 │ Antonio    │ Vivaldi   │ Composer
 1 │ Bob        │ Ross      │ Painter
 2 │ Octavia    │ Butler    │ Writer
───┴────────────┴───────────┴──────────
```

其他可用于字符串的指令有：
* split-row
* str
* lines
* size

如果我们已经知道数据具有 Nu 能够理解的格式，则可以调用一组帮助程序命令。 例如，我们打开一个 Cargo.lock 文件：

```
> open Cargo.lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
[[package]]
name = "adhoc_derive"
version = "0.1.2"
```

"Cargo.lock" 实际上是一个 .toml 文件，但是文件扩展名不是 .toml。也行，我们可以使用 `from toml` 命令：

```
> open Cargo.lock | from toml
──────────┬───────────────────
 metadata │ [row 107 columns]
 package  │ [table 130 rows]
──────────┴───────────────────
```

每种 Nu 能理解的格式都有对应的 `from` 命令可以使用。

## 以原始模式操作

虽然能够打开文件并立即使用其数据表很有帮助，但这并不总是我们想要做的。
为了获得纯文本，`open` 命令可以使用可选的 `--raw` 标志：

```
> open Cargo.toml --raw
[package]
name = "nu"
version = "0.1.3"
authors = ["Yehuda Katz <wycats@gmail.com>", "Jonathan Turner <jonathan.d.turner@gmail.com>"]
description = "A shell for the GitHub era"
license = "MIT"
```

## 获取 URLs

除了从文件系统加载文件之外，您还可以使用 `fetch` 命令加载 URL。 这将从互联网上获取URL的内容并将其返回给您：

```
> fetch https://www.jonathanturner.org/feed.xml
─────┬───────────────────────────
 rss │ [row attributes children]
─────┴───────────────────────────
```
